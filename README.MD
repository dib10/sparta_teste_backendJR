# Desafio TÃ©cnico - Sparta | API de CÃ¡lculo de Taxa

API REST que calcula o valor monetÃ¡rio da taxa de administraÃ§Ã£o a ser cobrada de cada cotista de um fundo de investimento.

## ğŸš€ Tecnologias

* **Python 3.12+**
* **FastAPI** - Framework para API
* **Uvicorn** - Servidor ASGI
* **Pydantic** - ValidaÃ§Ã£o de dados
* **Pytest** - Testes unitÃ¡rios

## âš™ï¸ Como Rodar

**1. Clone e configure:**
```bash
git clone https://github.com/dib10/sparta_teste_backendJR
cd sparta_teste_backendJR
python -m venv venv
.\venv\Scripts\Activate.ps1  # Windows
# source venv/bin/activate    # Linux/macOS
```

**2. Instale dependÃªncias:**
```bash
pip install -r requirements.txt
```

**3. Execute a API:**
```bash
uvicorn app.main:app --reload --port 8001
```

Acesse: `http://127.0.0.1:8001/docs` (Swagger UI)

## ğŸ§ª Testes

```bash
pytest
```

## ğŸ”§ Endpoints

### POST `/calcular`
Calcula a taxa de administraÃ§Ã£o para cada cotista.

**Request:**
```json
{
  "taxa": 0.01,
  "cotas": [
    {"valor": 10.50, "quantidades": [100, 200]},
    {"valor": 11.00, "quantidades": [100, 250]}
  ]
}
```

**Response:**
```json
[0.08531746031746032, 0.19246031746031744]
```

### GET `/`
Health check

## ğŸ“Š Estrutura

```
sparta_teste_backendJR/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py          # FastAPI app
â”‚   â”œâ”€â”€ schemas.py       # Pydantic models
â”‚   â”œâ”€â”€ services.py      # Business logic
â”‚   â””â”€â”€ exceptions.py    # Custom exceptions
â”œâ”€â”€ test_services.py     # Unit tests
â””â”€â”€ requirements.txt
```

## ğŸ›ï¸ DecisÃµes Principais que Tomei

A seguir, apresento as principais decisÃµes e a minha linha de pensamento durante o desenvolvimento do desafio.

### Desafios e Linha de Pensamento

O meu primeiro e principal desafio foi traduzir a fÃ³rmula matemÃ¡tica do ramo financeiro para uma estrutura de cÃ³digo que fosse limpa e fizesse sentido. A maior dificuldade foi, sem dÃºvida, "traduzir" a fÃ³rmula do mundo financeiro para a lÃ³gica de programaÃ§Ã£o (kkk).

*Nota: O brainstorm inicial que fiz no papel para entender a fÃ³rmula e planejar a implementaÃ§Ã£o estÃ¡ disponÃ­vel em PDF no repositÃ³rio.*

Para isso, segui uma abordagem de "dividir para conquistar". Em vez de colocar tudo numa Ãºnica funÃ§Ã£o, o meu primeiro passo foi quebrar a fÃ³rmula em partes lÃ³gicas. Comecei por definir uma funÃ§Ã£o sÃ³ para determinar o nÃºmero de cotistas (`_obter_num_cotistas`). Quis fazer assim para ter mais legibilidade no cÃ³digo e para que o entendimento da lÃ³gica matemÃ¡tica ficasse mais claro.

ApÃ³s isso, pensei que, se eu quebrasse em ainda mais funÃ§Ãµes, poderia ficar com muita engenharia para pouca coisa, entÃ£o decidi criar apenas duas funÃ§Ãµes auxiliares e uma funÃ§Ã£o principal que as chamaria. Com a lÃ³gica implementada, executei alguns testes bÃ¡sicos, principalmente para garantir que o nÃºmero de cotistas nÃ£o iria flutuar de um dia para o outro, conforme a regra prevista no enunciado. Depois disso, fiz alguns ajustes finais na separaÃ§Ã£o e organizaÃ§Ã£o dos ficheiros.

### Futuras ObservaÃ§Ãµes e Melhorias

Para este projeto, optei por manter a estrutura de ficheiros simples (`main.py`, `services.py`, etc.). No futuro, para um projeto ideal ou de maior escopo, eu certamente separaria o cÃ³digo em pastas mais especÃ­ficas, como `services/`, `controllers/` e `tests/`. Contudo, para a dimensÃ£o deste desafio, achei que isso limitaria muito os imports e o movimento entre os ficheiros, entÃ£o mantive uma abordagem mais direta.

## ğŸ‘¨â€ğŸ’» Autor

**Caio Dib** - Desenvolvedor Backend JÃºnior